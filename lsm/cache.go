/*
LSM 树缓存管理模块

缓存是 LSM 树性能优化的关键组件，通过在内存中缓存热点数据来减少磁盘 I/O。
JadeDB 实现了两级缓存架构：索引缓存和数据块缓存。

核心功能：
1. 索引缓存：缓存 SSTable 的索引信息，加速键查找
2. 块缓存：缓存数据块内容，减少重复的磁盘读取
3. LRU 策略：使用最近最少使用算法管理缓存空间
4. 内存控制：限制缓存大小，防止内存溢出

设计原理：
- 两级缓存：索引缓存和块缓存分离，优化不同访问模式
- 热点优化：频繁访问的数据保留在内存中
- 空间局部性：相邻的数据块可能被连续访问
- 时间局部性：最近访问的数据更可能再次被访问

缓存层次：
1. 索引缓存：存储 table 对象，包含文件的元数据和索引
2. 块缓存：存储原始数据块，避免重复解压和反序列化

性能优化：
- 预取策略：预测性地加载相关数据块
- 批量操作：批量更新缓存，减少锁竞争
- 内存对齐：优化内存布局，提高缓存命中率
- 异步清理：后台清理过期缓存项

内存管理：
- 大小限制：设置缓存的最大容量
- 自动淘汰：LRU 算法自动淘汰冷数据
- 内存监控：跟踪缓存使用情况
- 垃圾回收：配合 Go GC 优化内存使用

适用场景：
- 读密集型工作负载
- 热点数据访问
- 范围查询优化
- 迭代器性能提升
*/

package lsm

import (
	coreCache "github.com/util6/JadeDB/utils/cache"
)

// cache 实现 LSM 树的两级缓存系统。
// 通过缓存索引和数据块来显著提高读取性能。
//
// 缓存架构：
// 1. 索引缓存：缓存整个 table 对象，包含文件元数据
// 2. 块缓存：缓存解压后的数据块，避免重复解压
//
// 性能影响：
// - 索引缓存：减少文件打开和索引加载开销
// - 块缓存：减少磁盘 I/O 和数据解压开销
// - 组合效果：显著提升读取密集型工作负载的性能
//
// 内存使用：
// - 索引缓存：每个 table 对象约几KB到几十KB
// - 块缓存：每个数据块通常4KB-64KB
// - 总内存：可通过配置控制，建议设置为可用内存的10-30%
type cache struct {
	// 索引缓存

	// indexs 缓存 SSTable 的索引信息。
	// 键：文件 ID (fid)，值：table 对象
	// 缓存整个 table 对象，包含：
	// - 文件元数据（大小、键范围等）
	// - 块索引（用于快速定位数据块）
	// - 布隆过滤器（用于快速过滤不存在的键）
	indexs *coreCache.Cache

	// 数据块缓存

	// blocks 缓存解压后的数据块内容。
	// 键：复合键 (fid_blockOffset)，值：数据块字节数组
	// 缓存策略：
	// - 按需加载：只有被访问的块才会被缓存
	// - LRU 淘汰：最近最少使用的块会被淘汰
	// - 预取优化：可以预取相邻的数据块
	blocks *coreCache.Cache
}

// blockBuffer 是数据块的缓存包装器。
// 提供对原始数据块字节数组的封装。
//
// 设计目的：
// - 类型安全：避免直接使用 []byte 导致的类型混淆
// - 扩展性：未来可以添加更多元数据（如压缩信息、校验和等）
// - 内存管理：便于实现自定义的内存管理策略
type blockBuffer struct {
	// b 存储数据块的原始字节内容。
	// 这是从磁盘读取并解压后的数据。
	// 包含多个键值对的序列化数据。
	b []byte
}

const (
	// defaultCacheSize 定义默认的缓存容量。
	// 这是一个保守的默认值，适合大多数场景。
	// 生产环境中应该根据可用内存和工作负载调整。
	//
	// 容量计算：
	// - 索引缓存：1024个table对象，约10-50MB
	// - 块缓存：1024个数据块，约50-200MB
	// - 总计：约60-250MB，适合中等规模应用
	defaultCacheSize = 1024
)

// close 关闭缓存并释放相关资源。
// 当前实现为空，因为底层缓存会自动管理资源。
//
// 返回值：
// 总是返回 nil，表示关闭成功
//
// 设计说明：
// - 当前缓存实现不需要显式清理
// - 未来可能添加统计信息持久化等功能
// - 保持接口一致性，便于后续扩展
func (c *cache) close() error {
	return nil
}

// newCache 创建一个新的缓存实例。
// 使用默认配置初始化两级缓存系统。
//
// 参数说明：
// opt: LSM 树配置选项（当前未使用，预留扩展）
//
// 返回值：
// 初始化完成的缓存实例
//
// 初始化过程：
// 1. 创建索引缓存，用于存储 table 对象
// 2. 创建块缓存，用于存储数据块
// 3. 两个缓存都使用相同的默认大小
//
// 配置考虑：
// - 默认大小适合中等规模应用
// - 生产环境应根据内存和负载调整
// - 可以为不同缓存设置不同大小
func newCache(opt *Options) *cache {
	return &cache{
		indexs: coreCache.NewCache(defaultCacheSize),
		blocks: coreCache.NewCache(defaultCacheSize),
	}
}

// addIndex 将 table 对象添加到索引缓存中。
// 这个方法在打开 SSTable 文件时调用。
//
// 参数说明：
// fid: 文件的唯一标识符
// t: 要缓存的 table 对象
//
// 缓存策略：
// - 立即缓存：新打开的文件立即加入缓存
// - 覆盖更新：如果文件已存在，会更新缓存
// - LRU 管理：缓存满时会淘汰最少使用的项
//
// 性能影响：
// - 后续对同一文件的访问会直接从缓存获取
// - 避免重复的文件打开和索引加载开销
// - 特别适合热点文件的频繁访问
//
// TODO: 考虑使用数值类型的键以提高性能
// 当前使用 uint64 作为键，未来可能优化为更高效的格式
func (c *cache) addIndex(fid uint64, t *table) {
	c.indexs.Set(fid, t)
}

// getIndex 从索引缓存中获取 table 对象。
// 这个方法在需要访问 SSTable 文件时调用。
//
// 参数说明：
// fid: 要查找的文件标识符
//
// 返回值：
// 缓存的 table 对象，如果不存在则返回 nil
//
// 缓存命中：
// - 命中：直接返回缓存的 table 对象，避免文件操作
// - 未命中：返回 nil，调用者需要从磁盘加载文件
//
// 性能优势：
// - 避免重复的文件打开操作
// - 减少索引解析的 CPU 开销
// - 提高热点文件的访问速度
//
// 使用场景：
// - 查询操作前检查文件是否已缓存
// - 迭代器创建时获取文件信息
// - 压缩操作中访问源文件
func (c *cache) getIndex(fid uint64) *table {
	if val, ok := c.indexs.Get(fid); ok {
		return val.(*table)
	}
	return nil
}

// addBlock 将数据块添加到块缓存中。
// 这个方法在从磁盘读取数据块后调用。
//
// 参数说明：
// key: 块的缓存键，通常是 "fid_offset" 格式
// block: 要缓存的数据块内容
//
// 缓存策略：
// - 立即缓存：读取的数据块立即加入缓存
// - 覆盖更新：如果块已存在，会更新缓存内容
// - LRU 管理：缓存满时会淘汰最少使用的块
//
// 内存管理：
// - 数据块通常较大（4KB-64KB），需要注意内存使用
// - 使用 LRU 策略自动管理内存压力
// - 可以配置缓存大小限制内存使用
//
// 性能影响：
// - 后续对同一块的访问会直接从内存获取
// - 避免重复的磁盘 I/O 和解压操作
// - 特别适合顺序扫描和范围查询
func (c *cache) addBlock(key string, block []byte) {
	c.blocks.Set(key, &blockBuffer{b: block})
}

// getBlock 从块缓存中获取数据块。
// 这个方法在需要读取数据块时调用。
//
// 参数说明：
// key: 块的缓存键，通常是 "fid_offset" 格式
//
// 返回值：
// 缓存的数据块内容，如果不存在则返回 nil
//
// 缓存命中：
// - 命中：直接返回缓存的数据块，避免磁盘 I/O
// - 未命中：返回 nil，调用者需要从磁盘读取
//
// 性能优势：
// - 避免重复的磁盘读取操作
// - 减少数据解压的 CPU 开销
// - 提高热点数据的访问速度
//
// 使用场景：
// - 键值查找时读取数据块
// - 范围查询时扫描多个数据块
// - 迭代器遍历时访问连续数据块
//
// 内存安全：
// - 返回的字节数组是缓存的副本
// - 调用者可以安全地修改返回的数据
// - 不会影响缓存中的原始数据
func (c *cache) getBlock(key string) []byte {
	if val, ok := c.blocks.Get(key); ok {
		return val.(*blockBuffer).b
	}
	return nil
}

// removeIndex 从索引缓存中移除指定的 table 对象。
// 这个方法在文件被删除或替换时调用。
//
// 参数说明：
// fid: 要移除的文件标识符
//
// 使用场景：
// - 文件被压缩合并后删除旧文件
// - 垃圾回收时清理无效文件
// - 系统关闭时清理缓存
//
// 内存管理：
// - 移除缓存项会释放相关内存
// - 有助于控制缓存的内存使用
// - 防止缓存无限增长
//
// 注意事项：
// - 确保文件确实不再需要时才调用
// - 移除后的文件访问需要重新从磁盘加载
// - 可能影响正在使用该文件的操作
//
// 实现说明：
// 由于底层缓存使用 Del 方法进行删除操作，这里调用 Del 方法
func (c *cache) removeIndex(fid uint64) {
	c.indexs.Del(fid)
}

// Stats 返回缓存的统计信息。
// 用于监控缓存的使用情况和性能表现。
//
// 返回值：
// 包含缓存统计信息的映射表
//
// 统计指标：
// - 索引缓存：基本信息
// - 块缓存：基本信息
// - 总体状态：缓存系统的整体状态
//
// 使用场景：
// - 性能监控和调优
// - 容量规划和预警
// - 问题诊断和分析
// - 系统健康检查
//
// 实现说明：
// 由于底层缓存暂时没有详细的统计接口，这里提供基本的状态信息
// 未来可以扩展更详细的统计功能
func (c *cache) Stats() map[string]interface{} {
	return map[string]interface{}{
		"index_cache": map[string]interface{}{
			"type":        "index_cache",
			"description": "SSTable 索引缓存",
			"status":      "active",
		},
		"block_cache": map[string]interface{}{
			"type":        "block_cache",
			"description": "数据块缓存",
			"status":      "active",
		},
		"cache_system": map[string]interface{}{
			"type":        "two_level_cache",
			"description": "两级缓存系统",
			"status":      "running",
			"note":        "详细统计功能待实现",
		},
	}
}
