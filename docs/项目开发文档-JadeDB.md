---

此文档在项目开发中是有最高优先级的文档，是使用AI辅助开发要首先查看并遵循的文档，此文档负责记录大概的产品需求，具体的功能需求，开发时遇到的具体功能需求；开发可能用到的技术选型；
开发过程中遇到的每一个bug记录，以及解决bug用到的方法，错误的，正确的解决方法。以及过程中的知识经验总结
⚠️此文件只记录以上所说内容的关键（最精简，精炼的）信息，对于每一部分的具体详细说明在更具体的独立文档中，统一放在docs文件夹下，项目根目录下只有此文档和README.md文档

❗️此文档具有最高优先级，每次改动后都要提交git，如果项目有多个分支，也要保证每个分支的该文档保持最新一致的状态
---





# JadeDB项目开发文档



## Prompt for AI assistent（AI辅助开发提示词）





### 项目目标描述

此项目是我之前实现的一个不太完善的kv。
现在的目的是参考github上的优秀go语言数据库来完善本项目，同时达到我学习并模仿MySQL的目的
1.github.com/etcd-io/bbolt  go db中最接近 MySQL B+ 树的实现， 针对磁盘 I/O 优化，页面式存储（类似 MySQL）
2.github.com/lotusdblabs/lotusdb  同时支持 LSM 树和 B+ 树
3.CockroachDB、TiDB 实现一个完整的数据库系统，不仅只是存储引擎层

根据你提供的应农地比完整性标准分析的开发计划，给出一点补充建议：先优先实现页面管理，崩溃恢复
页面管理：固定大小页面，支持缓冲池
锁机制：行锁、表锁、意向锁
索引结构：聚簇索引和辅助索引
数据完整性：校验和、双写缓冲区
性能优化：自适应哈希索引、预读机制
把事物相关的功能放到最后集中开发或放到更高层开发
而且文件命名时要命名为bplustree，不要是btree会引起误解

### 开发环境描述

- **语言版本**: Go 1.24
- **主要依赖**:
  - github.com/cespare/xxhash/v2 (哈希算法)
  - github.com/golang/protobuf (序列化)
  - github.com/pkg/errors (错误处理)
  - github.com/stretchr/testify (测试框架)
- **开发工具**: 支持模糊测试(Fuzz Testing)、基准测试
- **平台支持**: Unix/Linux/Windows (通过条件编译)

### 功能需求描述

目前已经实现了LSM树
1.参考 github.com/lotusdblabs/lotusdb  完善LSM树
2.参考 github.com/etcd-io/bbolt  实现B+树 同时参考github.com/lotusdblabs/lotusdb  实现B+树与LSM树兼容
3.参考CockroachDB 逐步完善除了存储引擎之外的数据库高级特性





### 项目进度描述

**✅ 已完成功能 (Phase 1 - LSM树基础实现)**
- LSM树存储引擎核心架构
- 内存表(MemTable)与不可变表(Immutable)管理
- SSTable文件格式与多层级存储
- WAL(Write-Ahead Log)持久化机制
- 基础CRUD操作接口(Set/Get/Del/Iterator)
- MVCC事务支持与冲突检测
- Value Log分离存储大值优化
- 布隆过滤器查询优化
- 多级压缩(Compaction)策略
- 内存映射(mmap)文件访问
- 垃圾回收与磁盘空间管理

**✅ 已完成 (Phase 2 - PebbleDB优化策略全面实施)**
- **异步写入管道**: ✅ 完成三阶段流水线(WAL/内存表/同步)，支持Promise/Future模式
- **智能批量处理**: ✅ 完成自适应批量合并，支持去重和局部性优化
- **I/O调度优化**: ✅ 完成优先级队列调度，支持多类型工作池和任务重试
- **内存管理优化**: ✅ 完成对象池复用，支持自动GC触发和内存监控
- **压缩过程优化**: ✅ 完成并发压缩调度，支持任务优先级和资源限制
- **配置管理系统**: ✅ 完成多场景配置预设，支持动态配置调整
- **性能基准测试**: ✅ 完成全面的性能测试套件和对比分析
- **详细方案**: 参见 `docs/PebbleDB-优化方案.md` 和 `docs/PebbleDB-优化使用指南.md`

**✅ 已完成 (Phase 3.0 - B+树引擎基础设施)**
- **页面管理系统**: ✅ 16KB固定页面，CRC32校验，多文件支持
- **缓冲池管理**: ✅ LRU策略，16分区设计，脏页批量刷新
- **WAL日志系统**: ✅ 预写日志，LSN机制，组提交优化
- **崩溃恢复机制**: ✅ ARIES三阶段恢复，事务状态跟踪
- **性能优化组件**: ✅ 自适应哈希索引，智能预读器
- **测试覆盖**: ✅ 8个单元测试全部通过，性能基准达标
- **详细方案**: 参见 `docs/B+树引擎开发详细记录.md`

**🚧 进行中 (Phase 3.1 - B+树核心数据结构)**
- B+树节点实现（内部节点/叶子节点）
- 页面分裂与合并算法
- 键值查找和范围查询
- 聚簇索引实现

**📋 待实现功能 (Phase 3.2-3.3 - B+树完善)**
- 锁机制与并发控制（行锁、页锁、表锁）
- 数据完整性（双写缓冲区）
- 辅助索引支持
- 双引擎兼容层设计与实现

**🎯 长期目标 (Phase 4 - 高级特性)**
- SQL解析层(参考CockroachDB)
- 简单兼容sql语句（参考TiDB）
- 分布式架构支持
- 查询优化器

## 项目架构



### 技术选型

**存储引擎**: LSM树 + Value Log分离架构
- **优势**: 写入性能优异，适合写多读少场景
- **权衡**: 读放大问题通过布隆过滤器和缓存缓解

**并发控制**: MVCC + 时间戳排序
- **优势**: 读写不阻塞，支持快照隔离
- **权衡**: 内存开销较大，需要垃圾回收

**文件格式**: 自定义二进制格式 + Protocol Buffers
- **优势**: 紧凑存储，跨平台兼容
- **权衡**: 调试复杂度增加

**内存管理**: 内存池 + 跳表 + LRU缓存
- **优势**: 减少GC压力，提升性能
- **权衡**: 内存使用复杂度增加

### 核心设计（重点）

**1. 分层存储架构**
- L0层: 直接从内存表刷写，可能重叠
- L1-L6层: 有序不重叠，逐层压缩合并
- 压缩策略: 大小触发 + 定期后台压缩

**2. Value Log分离设计**
- 小值(<ValueThreshold): 直接存储在LSM树
- 大值(>=ValueThreshold): 存储在Value Log，LSM树存指针
- 垃圾回收: 基于引用计数的异步清理

**3. 事务实现机制**
- 读时间戳: 事务开始时获取
- 写时间戳: 提交时分配
- 冲突检测: 基于键指纹的快速检测
- 提交协议: 两阶段提交保证一致性

**4. 并发控制策略**
- 读写分离: 读操作无锁，写操作批量处理
- 内存表切换: 原子操作保证一致性
- 压缩并发: 多个压缩器并行工作
- 资源管理: 统一的Closer模式管理生命周期




### 项目目录结构

```
JadeDB/
├── db.go              # 数据库主接口，协调各组件
├── options.go         # 配置选项定义
├── stats.go          # 统计信息收集
├── txn.go            # 事务实现与MVCC控制
├── vlog.go           # Value Log大值存储
├── iterator.go       # 数据库级别迭代器
├── lsm/              # LSM树存储引擎
│   ├── lsm.go        # LSM树主控制器
│   ├── memtable.go   # 内存表实现
│   ├── table.go      # SSTable磁盘表
│   ├── levels.go     # 多层级管理器
│   ├── compact.go    # 压缩策略实现
│   ├── builder.go    # SSTable构建器
│   ├── cache.go      # 表和块缓存
│   ├── iterator.go   # LSM迭代器
│   ├── pipeline.go   # 异步提交管道
│   └── coalescer.go  # 智能批量合并器
├── file/             # 文件操作抽象层
│   ├── file.go       # 通用文件接口
│   ├── wal.go        # WAL文件实现
│   ├── logfile.go    # Value Log文件
│   ├── sstable_*.go  # 平台相关SSTable实现
│   ├── mmap_*.go     # 内存映射实现
│   └── manifest.go   # 元数据管理
├── utils/            # 工具库
│   ├── skiplist.go   # 跳表实现
│   ├── bloom.go      # 布隆过滤器
│   ├── entry.go      # 数据条目定义
│   ├── promise.go    # Promise/Future异步模式
│   ├── pool.go       # 对象池复用
│   ├── cache/        # LRU缓存实现
│   └── ...           # 其他工具函数
├── pb/               # Protocol Buffers定义
├── examples/         # 示例程序
│   └── pipeline_demo.go # 优化功能演示
└── docs/             # 项目文档
    ├── 项目开发文档-JadeDB.md
    ├── 优化功能使用指南.md
    └── PebbleDB-优化完成总结.md
```


## bug记录

**🐛 已知问题**
1. **目录锁缺失**: db.go:63 TODO注释提到缺少目录锁，可能导致多进程同时打开同一目录
2. **缓存键类型**: lsm/cache.go:28 TODO注释提到fid使用字符串可能有性能损耗
3. **WAL大小设置**: lsm/memtable.go:38 TODO注释提到WAL文件大小设置需要优化
4. **统计逻辑**: stats.go:47 硬编码EntryNum=1，需要实现真实统计逻辑

**✅ 重构后的PebbleDB优化实现**
1. **异步提交管道**: 已集成到lsm包，支持WAL/内存表/同步三阶段流水线
2. **智能批量合并**: 已集成到lsm包，支持自适应批量大小和去重优化
3. **对象池复用**: 已集成到utils包，支持Entry和Buffer对象复用
4. **Promise异步模式**: 已集成到utils包，支持Future/Promise异步编程
5. **性能基准测试**: 已重构基准测试套件，支持优化前后对比
6. **统计监控**: 已实现LSM层级的性能统计和监控指标
7. **API简化**: 通过LSM层统一管理优化功能，简化DB层接口
8. **演示程序**: 提供完整的性能对比演示
9. **文档完善**: 重新组织文档结构，提供简化的使用指南
10. **代码组织**: 按照Go项目最佳实践重新组织代码结构

**⚠️ 潜在风险**
- 并发压缩时的资源竞争
- 大量小文件导致的文件描述符耗尽
- Value Log垃圾回收的延迟问题
- 内存表切换时的数据一致性

## bug解决方案记录

**✅ 目录锁问题解决方案**
- **方案1**: 使用文件锁(flock)防止多进程访问
- **方案2**: 创建.lock文件作为进程标识
- **推荐**: 方案1，更可靠且跨平台兼容

**✅ 缓存性能优化方案**
- **问题**: 字符串键导致额外的内存分配和比较开销
- **解决**: 使用uint64直接作为map键，避免字符串转换
- **影响**: 预计可提升5-10%的缓存访问性能

**✅ WAL大小配置优化**
- **问题**: 当前WAL大小与SSTable相同，可能不是最优配置
- **解决**: 根据写入模式动态调整，或提供独立配置选项
- **建议**: WAL大小设为MemTableSize的1.2-1.5倍

**✅ 统计信息实现方案**
- **问题**: 硬编码统计数据，无法反映真实状态
- **解决**: 实现基于原子计数器的实时统计
- **包括**: EntryNum、MemTableSize、SSTableCount、CompactionCount等

---

## Phase 3: B+树存储引擎开发记录

### ✅ 已完成核心模块
1. **页面管理系统**: 16KB固定页面，CRC32校验，多文件支持
2. **缓冲池管理**: LRU策略，16分区设计，脏页批量刷新
3. **WAL日志系统**: 预写日志，LSN机制，组提交优化
4. **崩溃恢复机制**: ARIES三阶段恢复，事务状态跟踪
5. **性能优化组件**: 自适应哈希索引，智能预读器

**实现文件**: `bplustree/` 目录下8个核心文件
**测试覆盖**: 8个单元测试全部通过，性能基准达标

### 🐛 关键Bug修复记录

**✅ B+树引擎开发阶段Bug修复**
1. **类型重复声明**: LRUNode/MetaPage命名冲突 → 重命名为BufferLRUNode/BTreeMetaPage
2. **Closer接口调用错误**: 方法不存在 → 修正为Add()/CloseSignal/Close()
3. **文件大小不匹配**: mmap文件扩展失败 → 修复CreateMmapFile条件判断
4. **WAL头部大小错误**: 24字节不足 → 修正为33字节并重排字段布局
5. **WAL LSN初始化**: LSN为0问题 → 确保新文件LSN从1开始

**详细解决方案**: 参见 `docs/B+树引擎开发详细记录.md`

### 📊 测试与性能数据
**测试覆盖**: 8个单元测试全部通过 (0.772s)
**性能基准**: 页面校验~3μs，缓冲池访问~123ns (Apple M4)
**内存占用**: 基础约20MB，随缓冲池大小线性增长

### 🎯 关键开发经验
1. **并发设计**: 分区策略减少锁竞争，读写锁支持多读单写
2. **内存管理**: 对象复用减少GC，预分配避免动态扩容
3. **错误处理**: 分层错误设计，多层校验保证完整性
4. **测试驱动**: 单元+集成+性能测试，错误注入验证异常处理

### 🔄 下一阶段计划
**Phase 3.1**: B+树核心数据结构 (2-3周)
**Phase 3.2**: 锁机制与并发控制 (1-2周)
**Phase 3.3**: 数据完整性与性能优化 (1-2周)
