/*
JadeDB Window LRU 缓存实现

Window LRU 是多层级缓存系统的第一级缓存，专门用于捕获短期热点数据。
它实现了经典的 LRU（Least Recently Used）算法，但针对缓存系统的特定需求进行了优化。

核心特性：
1. 快速响应：捕获突发的访问模式和短期热点
2. 高效实现：O(1) 的插入、查找和删除操作
3. 容量控制：固定大小，防止内存无限增长
4. 淘汰策略：最近最少使用的数据优先被淘汰

设计原理：
- 哈希表 + 双向链表：结合两种数据结构的优势
- 哈希表：提供 O(1) 的查找性能
- 双向链表：维护访问顺序，支持高效的插入和删除
- 头部插入：新访问的数据移到链表头部
- 尾部淘汰：容量满时从链表尾部淘汰数据

在多层级缓存中的作用：
- 第一道防线：所有数据首先进入 Window LRU
- 热点识别：识别短期内的热点访问模式
- 缓存预热：为长期缓存提供候选数据
- 突发处理：快速响应突发的访问请求

性能优化：
- 内存复用：淘汰时复用链表节点，减少内存分配
- 指针操作：直接操作链表指针，避免数据拷贝
- 紧凑存储：优化数据结构布局，提高缓存命中率
*/

package cache

import (
	"container/list"
	"fmt"
)

// windowLRU 实现了窗口 LRU 缓存算法。
// 它是多层级缓存系统的第一级，负责捕获短期热点数据。
//
// 数据结构设计：
// - 哈希表：提供 O(1) 的键查找性能
// - 双向链表：维护数据的访问顺序
// - 链表头部：最近访问的数据
// - 链表尾部：最久未访问的数据
//
// 操作复杂度：
// - 查找：O(1) - 通过哈希表直接定位
// - 插入：O(1) - 头部插入，可能需要尾部淘汰
// - 更新：O(1) - 移动到头部
// - 删除：O(1) - 直接从链表和哈希表中移除
//
// 内存管理：
// - 固定容量：防止内存无限增长
// - 节点复用：淘汰时复用链表节点
// - 紧凑布局：优化内存访问模式
type windowLRU struct {
	// 快速查找结构

	// data 是哈希表，提供 O(1) 的键查找性能。
	// 键：缓存项的哈希值（uint64）
	// 值：双向链表中对应节点的指针
	// 这种设计避免了在链表中线性搜索的开销。
	data map[uint64]*list.Element

	// 容量控制

	// cap 是缓存的最大容量（条目数量）。
	// 当缓存达到此容量时，会触发 LRU 淘汰策略。
	// 容量设置需要平衡内存使用和缓存效果。
	cap int

	// 访问顺序维护

	// list 是双向链表，维护缓存项的访问顺序。
	// 链表头部：最近访问的数据（热点数据）
	// 链表尾部：最久未访问的数据（候选淘汰数据）
	// 每次访问都会将对应节点移动到头部。
	list *list.List
}

// storeItem 表示缓存中存储的一个数据项。
// 它包含了缓存项的所有必要信息，支持多层级缓存的复杂操作。
//
// 设计考虑：
// 1. 多层级支持：stage 字段标识数据在哪个缓存层级
// 2. 冲突处理：conflict 字段用于处理哈希冲突
// 3. 灵活存储：value 字段支持任意类型的数据
// 4. 高效查找：key 字段提供快速的数据定位
//
// 内存布局：
// 结构体字段按照访问频率和对齐要求排列，优化内存访问性能。
type storeItem struct {
	// 缓存层级标识

	// stage 标识数据项在多层级缓存中的位置。
	// 可能的值：
	// - 0: Window LRU（第一级缓存）
	// - 1: Segmented LRU 的 Probation 区（试用区）
	// - 2: Segmented LRU 的 Protected 区（保护区）
	stage int

	// 数据标识

	// key 是数据项的主键，用于唯一标识缓存项。
	// 通常是原始键的哈希值，提供快速的比较和查找。
	key uint64

	// 冲突解决

	// conflict 用于处理哈希冲突的辅助键。
	// 当多个原始键映射到相同的哈希值时，使用此字段进行区分。
	// 通常是原始键的另一个哈希值或校验和。
	conflict uint64

	// 实际数据

	// value 存储缓存项的实际数据。
	// 使用 interface{} 类型支持任意类型的数据存储。
	// 在实际使用时需要进行类型断言。
	value interface{}
}

// newWindowLRU 创建一个新的窗口 LRU 缓存实例。
// 这是 windowLRU 的构造函数，初始化所有必要的数据结构。
//
// 参数说明：
// size: 缓存的最大容量（条目数量）
// data: 共享的哈希表，用于跨缓存层级的数据查找
//
// 返回值：
// 初始化完成的 windowLRU 实例
//
// 设计考虑：
// - 共享哈希表：多个缓存层级共享同一个哈希表，提高查找效率
// - 独立链表：每个层级有独立的链表，维护各自的访问顺序
// - 容量控制：通过 size 参数控制缓存大小，防止内存溢出
func newWindowLRU(size int, data map[uint64]*list.Element) *windowLRU {
	return &windowLRU{
		data: data,       // 共享的哈希表
		cap:  size,       // 缓存容量
		list: list.New(), // 新的双向链表
	}
}

// add 向窗口 LRU 缓存中添加一个新的数据项。
// 这是缓存的核心操作，实现了 LRU 的插入和淘汰逻辑。
//
// 参数说明：
// newItem: 要添加的新数据项
//
// 返回值：
// oldItem: 被淘汰的数据项（如果发生淘汰）
// evicted: 是否发生了淘汰操作
//
// 操作逻辑：
// 1. 检查缓存是否已满
// 2. 如果未满：直接插入到链表头部
// 3. 如果已满：淘汰尾部数据，插入新数据到头部
//
// 性能优化：
// - 节点复用：淘汰时复用链表节点，避免内存分配
// - 原地替换：直接修改节点内容，减少指针操作
// - 批量更新：同时更新哈希表和链表，保持一致性
//
// 内存管理：
// - 零分配：在淘汰场景下不分配新内存
// - 引用更新：及时更新哈希表引用，防止悬空指针
func (lru *windowLRU) add(newItem storeItem) (oldItem storeItem, evicted bool) {
	// 情况1：缓存未满，直接添加
	if lru.list.Len() < lru.cap {
		// 将新项添加到链表头部（最近访问位置）
		lru.data[newItem.key] = lru.list.PushFront(&newItem)
		return storeItem{}, false
	}

	// 情况2：缓存已满，需要执行 LRU 淘汰

	// 获取链表尾部的节点（最久未访问的数据）
	evictItem := lru.list.Back()

	// 类型断言：将链表节点的值转换为 storeItem 指针
	// 这里使用指针是为了能够直接修改节点内容
	item := evictItem.Value.(*storeItem)

	// 从哈希表中删除被淘汰项的映射
	delete(lru.data, item.key)

	// 关键优化：原地替换节点内容，复用内存空间
	// oldItem 保存被淘汰的数据，*item 更新为新数据
	oldItem, *item = *item, newItem

	// 更新哈希表：将新项的键映射到复用的链表节点
	lru.data[item.key] = evictItem

	// 将更新后的节点移动到链表头部（最近访问位置）
	lru.list.MoveToFront(evictItem)

	return oldItem, true
}

// get 将指定的缓存项标记为最近访问。
// 这个方法实现了 LRU 算法的核心：将访问的数据移动到最前面。
//
// 参数说明：
// v: 要标记为最近访问的链表元素
//
// 操作说明：
// - 将指定元素移动到链表头部
// - 表示该数据是最近被访问的
// - 降低该数据被淘汰的优先级
//
// 性能特点：
// - O(1) 时间复杂度
// - 只涉及指针操作，无内存分配
// - 高效的访问模式更新
//
// 使用场景：
// - 缓存命中时调用
// - 更新数据的访问时间
// - 维护 LRU 访问顺序
func (lru *windowLRU) get(v *list.Element) {
	lru.list.MoveToFront(v)
}

// String 返回窗口 LRU 缓存内容的字符串表示。
// 这个方法主要用于调试、日志记录和系统监控。
//
// 返回值：
// 包含所有缓存项信息的格式化字符串
//
// 输出格式：
// 按照访问顺序（从最近到最久）列出所有缓存项
// 每个项显示其键值和相关信息
// 项之间用逗号分隔，便于阅读
//
// 使用场景：
// - 调试缓存状态和访问模式
// - 监控缓存内容的变化
// - 分析缓存的命中率和效率
// - 故障诊断和性能调优
//
// 性能考虑：
// - 遍历整个链表，时间复杂度 O(n)
// - 字符串拼接操作，可能产生临时对象
// - 建议只在调试或监控时使用
func (lru *windowLRU) String() string {
	var s string
	for e := lru.list.Front(); e != nil; e = e.Next() {
		s += fmt.Sprintf("%v,", e.Value.(*storeItem).value)
	}
	return s
}
