/*
JadeDB 键处理工具模块

本模块提供了键相关的核心工具函数，支持 MVCC 和高性能操作：
- 键时间戳处理：支持 MVCC 的键版本管理
- 高性能哈希：使用硬件加速的哈希函数
- 键比较和解析：高效的键操作工具
- 内存安全操作：零拷贝和安全复制

核心设计：
1. 键格式：[原始键][8字节时间戳]，支持多版本存储
2. 时间戳编码：使用反向编码确保新版本排在前面
3. 硬件加速：利用 AES 指令集优化哈希计算
4. 内存优化：使用 unsafe 操作减少内存分配

MVCC 支持：
- 每个键可以有多个版本，通过时间戳区分
- 时间戳使用反向编码，确保新版本在 LSM 树中排序靠前
- 支持快照隔离，不同事务看到不同版本的数据

性能优化：
- 使用 Go 运行时的内部哈希函数，支持硬件加速
- 零拷贝操作，减少内存分配和复制开销
- 高效的键比较和解析算法
*/

package utils

import (
	"bytes"
	"encoding/binary"
	"math"
	"time"
	"unsafe"
)

// stringStruct 表示字符串的内部结构。
// 这个结构体用于 unsafe 操作，直接访问字符串和字节切片的底层数据。
// 通过这种方式可以避免数据复制，提高哈希计算的性能。
//
// 注意：这是一个底层优化，依赖于 Go 运行时的内部实现。
// 在不同的 Go 版本中可能需要调整。
type stringStruct struct {
	// str 指向字符串数据的指针。
	// 直接指向内存中的字符串内容，避免复制。
	str unsafe.Pointer

	// len 是字符串的长度。
	// 与 str 指针配合，完整描述一个字符串。
	len int
}

// memHash 是 Go 运行时内部使用的哈希函数。
// 通过 go:linkname 指令直接调用运行时的 memHash 函数。
//
// 性能特点：
// 1. 硬件加速：在支持 AES 指令的 CPU 上使用 aeshash
// 2. 高质量：与 Go map 使用相同的哈希算法
// 3. 快速：针对短字符串和长字符串都有优化
//
// 安全注意：
// - 哈希种子在每个进程启动时随机生成
// - 不能用作持久化哈希，只适合内存中使用
// - 不同进程对相同数据的哈希值可能不同
//
//go:noescape
//go:linkname memHash runtime.memHash
func memHash(p unsafe.Pointer, h, s uintptr) uintptr

// ParseKey 从带时间戳的键中提取原始键部分。
// 在 JadeDB 的 MVCC 实现中，键的格式为 [原始键][8字节时间戳]。
// 这个函数用于从完整键中提取用户的原始键。
//
// 参数说明：
// key: 可能包含时间戳的完整键
//
// 返回值：
// 原始键部分，如果键长度不足8字节则返回原键
//
// 实现逻辑：
// - 如果键长度小于8字节，说明没有时间戳，直接返回
// - 否则返回除最后8字节外的所有内容
//
// 使用场景：
// - 从存储中读取数据时提取用户键
// - 在迭代器中向用户返回原始键
// - 键比较时忽略时间戳部分
func ParseKey(key []byte) []byte {
	if len(key) < 8 {
		return key
	}

	return key[:len(key)-8]
}

// ParseTs 从带时间戳的键中提取时间戳。
// 时间戳存储在键的最后8字节，使用反向编码以确保排序正确。
//
// 参数说明：
// key: 可能包含时间戳的完整键
//
// 返回值：
// 解析出的时间戳，如果键长度不足则返回0
//
// 编码格式：
// 时间戳使用 math.MaxUint64 - ts 的方式编码，这样：
// - 较新的版本（更大的时间戳）会有较小的编码值
// - 在字典序排序中，新版本会排在旧版本前面
// - 符合 LSM 树中新数据优先的原则
//
// 使用场景：
// - MVCC 版本控制
// - 事务可见性判断
// - 垃圾回收时确定版本新旧
func ParseTs(key []byte) uint64 {
	if len(key) <= 8 {
		return 0
	}
	return math.MaxUint64 - binary.BigEndian.Uint64(key[len(key)-8:])
}

// SameKey 检查两个键是否表示同一个逻辑键。
// 这个函数忽略时间戳部分，只比较原始键内容。
//
// 参数说明：
// src, dst: 要比较的两个键（可能包含时间戳）
//
// 返回值：
// 如果两个键的原始部分相同则返回 true
//
// 实现逻辑：
// 1. 首先检查长度是否相同（优化：长度不同肯定不相等）
// 2. 然后比较解析后的原始键部分
//
// 使用场景：
// - 检查不同版本是否属于同一个键
// - 在压缩过程中合并同一键的多个版本
// - 冲突检测中判断键冲突
//
// 性能考虑：
// - 长度检查是快速路径，避免不必要的解析
// - 使用 bytes.Equal 进行高效的字节比较
func SameKey(src, dst []byte) bool {
	if len(src) != len(dst) {
		return false
	}
	return bytes.Equal(ParseKey(src), ParseKey(dst))
}

// KeyWithTs 为原始键添加时间戳，生成 MVCC 键。
// 这是创建版本化键的核心函数，用于实现多版本并发控制。
//
// 参数说明：
// key: 原始键（用户提供的键）
// ts: 时间戳（通常是事务时间戳）
//
// 返回值：
// 包含时间戳的完整键
//
// 编码格式：
// [原始键][8字节反向编码的时间戳]
// 时间戳使用 math.MaxUint64 - ts 编码，确保：
// - 新版本在字典序中排在前面
// - 读取时优先访问最新版本
// - 符合 LSM 树的数据组织原则
//
// 使用场景：
// - 写入数据时为键添加事务时间戳
// - 创建快照读的查询键
// - 实现 MVCC 的版本控制
//
// 内存分配：
// - 分配新的字节数组，长度为原键长度+8
// - 复制原键内容，追加编码后的时间戳
// - 调用者负责管理返回的内存
func KeyWithTs(key []byte, ts uint64) []byte {
	out := make([]byte, len(key)+8)
	copy(out, key)
	binary.BigEndian.PutUint64(out[len(key):], math.MaxUint64-ts)
	return out
}

// MemHash 计算字节切片的高性能哈希值。
// 使用 Go 运行时内部的哈希函数，支持硬件加速。
//
// 参数说明：
// data: 要计算哈希的字节切片
//
// 返回值：
// 64位哈希值
//
// 性能特点：
// 1. 硬件加速：在支持 AES-NI 的 CPU 上使用 aeshash
// 2. 零拷贝：通过 unsafe 操作直接访问底层数据
// 3. 高质量：与 Go map 使用相同的哈希算法
// 4. 快速：针对不同长度的数据都有优化
//
// 安全注意：
// - 哈希种子在进程启动时随机生成
// - 相同数据在不同进程中的哈希值可能不同
// - 不适合用作持久化哈希或跨进程通信
//
// 使用场景：
// - 内存中的哈希表和集合
// - 布隆过滤器的哈希函数
// - 快速数据去重和比较
// - 缓存键的生成
func MemHash(data []byte) uint64 {
	ss := (*stringStruct)(unsafe.Pointer(&data))
	return uint64(memHash(ss.str, 0, uintptr(ss.len)))
}

// MemHashString 计算字符串的高性能哈希值。
// 与 MemHash 类似，但直接处理字符串类型，避免类型转换。
//
// 参数说明：
// str: 要计算哈希的字符串
//
// 返回值：
// 64位哈希值
//
// 性能优势：
// - 直接处理字符串，避免到字节切片的转换
// - 零拷贝访问字符串的底层数据
// - 与字节切片版本使用相同的高性能算法
//
// 使用场景：
// - 字符串键的哈希表
// - 字符串去重和比较
// - 缓存键生成
// - 快速字符串索引
//
// 注意事项：
// - 与 MemHash 有相同的安全限制
// - 不能用于持久化或跨进程场景
func MemHashString(str string) uint64 {
	ss := (*stringStruct)(unsafe.Pointer(&str))
	return uint64(memHash(ss.str, 0, uintptr(ss.len)))
}

// SafeCopy 安全地复制字节切片，重用目标切片的底层数组。
// 这是一个内存优化的复制函数，可以减少内存分配。
//
// 参数说明：
// a: 目标切片，其底层数组将被重用
// src: 源数据切片
//
// 返回值：
// 包含源数据的新切片，可能重用了 a 的底层数组
//
// 工作原理：
// 1. 将目标切片长度重置为0（但保留容量）
// 2. 使用 append 将源数据追加到重置后的切片
// 3. 如果容量足够，会重用底层数组；否则分配新数组
//
// 性能优势：
// - 重用内存，减少垃圾回收压力
// - 避免不必要的内存分配
// - 适合在循环中重复使用缓冲区
//
// 使用场景：
// - 缓冲区重用和内存池
// - 临时数据的安全复制
// - 避免数据共享的防御性复制
//
// 注意事项：
// - 返回的切片与源切片不共享内存
// - 目标切片的原有内容会被覆盖
// - 如果需要保留原有数据，应使用其他方法
func SafeCopy(a, src []byte) []byte {
	return append(a[:0], src...)
}

// NewCurVersion 生成当前时间的版本时间戳。
// 返回当前时间的 Unix 时间戳（秒级精度）。
//
// 返回值：
// 当前时间的 Unix 时间戳（秒）
//
// 用途：
// - 为新事务生成时间戳
// - 创建数据版本标识
// - 实现基于时间的过期机制
//
// 精度说明：
// - 使用秒级精度，适合大多数应用场景
// - 如果需要更高精度，可以考虑使用纳秒或微秒
//
// 注意事项：
// - 依赖系统时钟，时钟回拨可能影响正确性
// - 在高并发场景下，可能产生相同的时间戳
// - 建议结合其他机制确保时间戳的唯一性
func NewCurVersion() uint64 {
	return uint64(time.Now().UnixNano() / 1e9)
}
